#!/usr/bin/env bash

#
# Bash long-argument script template
# Please see the USAGE, AUTHOR and VERSION variables below for more information.
#

# We need to get the pathname first before doing anything else or it will change
PATHNAME="$_";

# Exit on uncaught error, disallow unset variables and raise an error if any
# command in a pipe fails
set -euo pipefail;

# Note whether the script is sourced and get the script's path
if [[ "$PATHNAME" != "$0" ]]; then
    SCRIPT_PATH="${BASH_SOURCE[0]}";
    SCRIPT_SOURCED="yes";
else
    SCRIPT_PATH="$0";
    SCRIPT_SOURCED="no";
fi

SCRIPT_NAME=$(basename "${SCRIPT_PATH}");
SCRIPT_DIRECTORY=$(dirname "${SCRIPT_PATH}");

# Default parameter values
# Requires bash 4.0+ to declare an associative array.
declare -A parameters;
parameters[rmd_file]="";
parameters[img_dir]="";
parameters[output_file]="";

# Script metadata
VERSION=$(cd "${SCRIPT_DIRECTORY}" && git describe --always --tags --dirty);
AUTHOR="Fong Chun Chan <fongchunchan@gmail.com>";
USAGE="
Usage:

    ${SCRIPT_NAME} [OPTIONS]

Description:

    This is a template for bash scripts that require long-argument names. Such
    scripts require gnu getopts and so are less portable than regular
    short-argument bash scripts.

Options:

    --rmd-file FILENAME
        The rmarkdown file to knit

    --img-dir FILENAME
        The name of the folder to store the images associated with this
        --rmd-file

    -v --version
        Print script name and version.

    -u -h --usage --help
        Print this usage/help information.

";

# The main function of the script
main() {
    # Parse the command line arguments. If it has a non-zero exit status, the
    # main function should return immediately. If $noerror is not "yes", main()
    # should return the same exit status, otherwise it is a clean exit 0;
    noerror="";
    parseargs "$@";
    parseargs_status=$?;
    if [[ "${parseargs_status}" -gt 0 ]]; then
        [[ "${noerror}" == "yes" ]] && return 0;
        return "${parseargs_status}";
    fi

    # Directory where the knitted post will be saved to
    out_dir="../_posts";

    if [[ ! -d "${out_dir}" ]]; then
        echo "Post directory ${out_dir} does not exist";
    fi

    # Output file name will take the same file name, but with .md as the suffix
    output_file="${out_dir}/$(date +%Y-%m-%d)-${parameters[rmd_file]%.Rmd}.md";

    # Specify a temporarily location to store the images generated by the 
    # `r-to-jekyll.R` script. This will be relative to the current run 
    # directory. These images will all be moved into the top level assets 
    # folder later.
    tmp_img_dir="{{ site.url }}/assets/${parameters[img_dir]}";

    ./r_to_jekyll.R \
        --rmd-file "${parameters[rmd_file]}" \
        --img-dir "${tmp_img_dir}" \
        --output-file "${output_file}" 

    # Final directory of where the images will be copied to. This is relative
    # to the top level directory of this blog.
    final_img_dir="../assets/${parameters[img_dir]}";
    [[ -d "${final_img_dir}" ]] || mkdir -p "${final_img_dir}";

    # Using -type ensures that symbolic links or folders are not copied
    while IFS= read -r -d '' file; do
       rsync "${file}" "${final_img_dir}";
    done < <(find "${tmp_img_dir}" -type f -print0)
    echo "Images copied to ${final_img_dir}";

    return 0;
}

# Print usage information
usage() {
    local error="${1:-}";
    version;

    if [[ ! -z "${error}" ]]; then
        >&2 echo "";
        >&2 echo "    Error: ${error}";
    fi

    >&2 echo "${USAGE}";
}

# Print the script version
version() {
    >&2 echo "${SCRIPT_NAME} version ${VERSION}";
    >&2 echo "${AUTHOR}";
}

# Parse the command line arguments
parseargs() {
    # Check that we have GNU getopt
    getopt_version=$(getopt -V);
    gnu_getopt_version_regex="^getopt .* [0-9]+\.[0-9]+\.[0-9]+$";
    if [[ ! "${getopt_version}" =~ $gnu_getopt_version_regex ]]; then
        usage "Incompatible version of getopt detected. GNU getopt is required";
        return 1;
    fi

    local args=("$@");
    local idx="0";
    while [[ "${idx}" -lt "${#args[@]}" ]]; do
        local this_arg="${args[$idx]}";
        local next_arg="${args[((idx + 1))]:-}";
        
        case "${this_arg}" in
            --img-dir)
                parameters[img_dir]="${next_arg}";
                (( idx ++ ));
                ;;

            --rmd-file)
                parameters[rmd_file]="${next_arg}";
                (( idx ++ ));
                ;;

            -v | --version)
                version;
                noerror="yes";
                return 1;
                ;;
                
            -u | -h | --usage | --help)
                usage;
                noerror="yes";
                return 1;
                ;;
                
            --)
                (( idx ++ ));
                break;
                ;;
                
            -*)
                usage "Unrecognised option: ${this_arg}";
                return 1;
                ;;
                
            *)
                break;
                ;;
            
        esac
        
        (( idx ++ ));
    done

    if [[ -z "${parameters[rmd_file]}" ]]; then
        >&2 echo "--rmd-file must be specified";
        return 1;
    fi
    
    if [[ ! -f "${parameters[rmd_file]}" ]]; then
        >&2 echo "${parameters[rmd_file]} does not exists";
        return 1;
    fi

    if [[ -z "${parameters[img_dir]}" ]]; then
        parameters[img_dir]="${parameters[rmd_file]%.Rmd}";
        >&2 echo "Setting --img-dir to ${parameters[img_dir]}";
    fi
    
    return 0;
}

# Execute the script, capturing the return value in a way that will work even if
# the script is sourced
exitstatus=0;
main "$@" || exitstatus=$?;

if [[ "${SCRIPT_SOURCED}" == "no" ]]; then
    exit "${exitstatus}";
else
    set +e;
    return "${exitstatus}";
fi
