---
title:  "Use the .data and .env pronouns to be disambiguous in your Tidyverse code"
date: "December 14th, 2018"
layout: post
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: hide
tags: [R, stats, bayesian]
---

```{r echo = FALSE}
# Keep this when you are rendering this rmarkdown not through the r-to-jekyll.R
# script
library("knitr")
opts_chunk$set(dev = c("CairoSVG"))
```

I have recently been going through the set 

* Been using R 
* Tension between using it in interactive mode and non-interactive mode.

This issue was nicely highlighted in a recent talk titled "Interactivity and 
Programming in the tidyverse" at rconf::2020 by Lionel Henry title. In that 
talk, it discusses how R has a data masking feature allows you to "blend your 
data with the workspace". In essence, it allows you to do something like:

```{r}
dplyr::filter(mtcars, cyl == carb)
```

Here the `dplyr::filter` function knows that you are filtering for rows where 
the cyl column matches the carb column. If you now do this:

```{r}
num_cyl <- 6
dplyr::filter(mtcars, cyl == num_cyl)
```

Here the `dplyr::filter` function knows that you are filtering for rows where 
the cyl column matches the value stored in the `num_cyl` variable because there
is no column name called `num_cyl`. But what do you expect to happen with this 
piece of code?

```{r}
carb <- 6
dplyr::filter(mtcars, cyl == carb)
```

You might have expected it to return all rows where the `cyl` column was a 6
as the `carb` variable was set to 6. In this case, the `mtcars` dataframe had a
column name called `carb` and this actually takes precedence over the value in
the variable. To me, that was unexpected behaviour. 

This is generally not a big issue when you are using R in interactive mode. This
is because you would know which variables are in your workspace and what the 
column names are in your dataframe. Additionally, if you ran into this issue 
where you had a column name that matched a variable name, you could just rename
the column name or variable and just move on.

However when writing production level R code, you might not have this luxury.
You really want to be disambiguous in what values the R code should be using.
So what's the solution? It is to use the pronouns `.data` and `.env` so refer to
your dataframe and workspace respectively. In this case:

```{r}
carb <- 6
dplyr::filter(mtcars, .data[["cyl"]] == .env[["carb"]])
```

would produce the intended results. The `.data[["cyl"]]` tells `dplyr::filter`
to filter on the cyl column in the `mtcars` dataframe. The `.env[["carb"]]`
indicates that we should be filtering on the value stored in the workspace
variable `carb` and NOT the carb column in `mtcars`. If you had wanted 

Here we have an unintended result here. I would have expected that the dataframe 
is being filtered for rows that have the cyl column being equal to 6. But it is 
actually returning rows where the cyl column and carb column are equal. This 
where the data masking 
are experiencing unexpected data masking where the column name has precedence over the variable name and masks the value in the carb data-variable. This is in essence the issue with data masking because it creates ambiguity between data-variables and environment variables (workspace).

In conclusion, make sure to use the `.data` and `env` pronouns in your R code!
I have basically gotten into the habit of doing this regardless whether I am 
writing production-level code or not. As far as I can tell, there is no harm in
being explicit in my R code aside from the extra few characters you have to 
type.

# References
---

* [Interactivity and Programming in the Tidyverse - Lionel Henry](https://resources.rstudio.com/rstudio-conf-2020/interactivity-and-programming-in-the-tidyverse-lionel-henry)
